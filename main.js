/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
var import_obsidian = __toModule(require("obsidian"));
function getLocalizedText(key, language) {
  var _a;
  const texts = {
    "january": { en: "January", zh: "\u4E00\u6708" },
    "february": { en: "February", zh: "\u4E8C\u6708" },
    "march": { en: "March", zh: "\u4E09\u6708" },
    "april": { en: "April", zh: "\u56DB\u6708" },
    "may": { en: "May", zh: "\u4E94\u6708" },
    "june": { en: "June", zh: "\u516D\u6708" },
    "july": { en: "July", zh: "\u4E03\u6708" },
    "august": { en: "August", zh: "\u516B\u6708" },
    "september": { en: "September", zh: "\u4E5D\u6708" },
    "october": { en: "October", zh: "\u5341\u6708" },
    "november": { en: "November", zh: "\u5341\u4E00\u6708" },
    "december": { en: "December", zh: "\u5341\u4E8C\u6708" },
    "files": { en: "files", zh: "\u6587\u4EF6" },
    "notes": { en: "notes", zh: "\u7B14\u8BB0" },
    "filesAndNotes": { en: "files, notes", zh: "\u6587\u4EF6\uFF0C\u7B14\u8BB0" },
    "totalFiles": { en: "Total", zh: "\u603B\u8BA1" },
    "filesTotal": { en: "files", zh: "\u4E2A\u6587\u4EF6" },
    "notesTotal": { en: "notes", zh: "\u4E2A\u7B14\u8BB0" },
    "includingSubdirectories": { en: "including subdirectories", zh: "\uFF08\u5305\u542B\u5B50\u76EE\u5F55\uFF09" },
    "sunday": { en: "Sun", zh: "\u65E5" },
    "monday": { en: "Mon", zh: "\u4E00" },
    "tuesday": { en: "Tue", zh: "\u4E8C" },
    "wednesday": { en: "Wed", zh: "\u4E09" },
    "thursday": { en: "Thu", zh: "\u56DB" },
    "friday": { en: "Fri", zh: "\u4E94" },
    "saturday": { en: "Sat", zh: "\u516D" },
    "notesCalendar": { en: "Notes Calendar", zh: "\u7B14\u8BB0\u65E5\u5386" },
    "yearView": { en: "Year View", zh: "\u5E74\u89C6\u56FE" },
    "monthView": { en: "Month View", zh: "\u6708\u89C6\u56FE" },
    "locatedToFile": { en: "Located to file", zh: "\u5DF2\u5B9A\u4F4D\u5230\u6587\u4EF6" },
    "jumpedToMonthView": { en: "Jumped to", zh: "\u5DF2\u8DF3\u8F6C\u5230" },
    "monthViewAbbr": { en: "month view", zh: "\u6708\u89C6\u56FE" },
    "switchView": { en: "Switch view", zh: "\u5207\u6362\u89C6\u56FE" },
    "currentView": { en: "Current", zh: "\u5F53\u524D" },
    "yearToMonth": { en: "\u{1F4C5}", zh: "\u{1F4C5}" },
    "monthToYear": { en: "\u{1F4C6}", zh: "\u{1F4C6}" },
    "switchViewTooltip": { en: "Click to switch view (Current: {current})", zh: "\u70B9\u51FB\u5207\u6362\u89C6\u56FE (\u5F53\u524D: {current})" }
  };
  return ((_a = texts[key]) == null ? void 0 : _a[language]) || key;
}
function getMonthNames(language) {
  return [
    getLocalizedText("january", language),
    getLocalizedText("february", language),
    getLocalizedText("march", language),
    getLocalizedText("april", language),
    getLocalizedText("may", language),
    getLocalizedText("june", language),
    getLocalizedText("july", language),
    getLocalizedText("august", language),
    getLocalizedText("september", language),
    getLocalizedText("october", language),
    getLocalizedText("november", language),
    getLocalizedText("december", language)
  ];
}
function getWeekdayNames(language) {
  return [
    getLocalizedText("sunday", language),
    getLocalizedText("monday", language),
    getLocalizedText("tuesday", language),
    getLocalizedText("wednesday", language),
    getLocalizedText("thursday", language),
    getLocalizedText("friday", language),
    getLocalizedText("saturday", language)
  ];
}
function formatFileCountText(totalFiles, totalNotes, language) {
  const filesText = getLocalizedText("files", language);
  const notesText = getLocalizedText("notes", language);
  if (language === "en") {
    return `(${totalFiles} ${filesText}, ${totalNotes} ${notesText})`;
  } else {
    return `\uFF08${totalFiles}${filesText}${totalNotes}${notesText}\uFF09`;
  }
}
function formatFileCountTooltip(totalFiles, totalNotes, language) {
  const totalText = getLocalizedText("totalFiles", language);
  const filesText = getLocalizedText("filesTotal", language);
  const notesText = getLocalizedText("notesTotal", language);
  const includingText = getLocalizedText("includingSubdirectories", language);
  if (language === "en") {
    return `${totalText} ${totalFiles} ${filesText}, ${totalNotes} ${notesText} ${includingText}`;
  } else {
    return `${totalText} ${totalFiles}${filesText}\uFF0C\u5176\u4E2D ${totalNotes}${notesText}${includingText}`;
  }
}
var DEFAULT_SETTINGS = {
  showCreationDate: true,
  showModificationDate: true,
  dateFormat: "YYYY-MM-DD",
  enableCalendarView: true,
  calendarFirstDayOfWeek: 0,
  showFileCount: true,
  calendarViewType: "year",
  sortOrder: "desc",
  showSubdirectoryStats: true,
  language: "zh"
};
var CALENDAR_VIEW_TYPE = "notes-calendar-view";
var NotesDatesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian.TFile) {
        this.updateFileDisplay(file);
      }
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile) {
        this.updateFileDisplay(file);
      }
    }));
    this.addCommand({
      id: "toggle-sort-by-modified",
      name: "Toggle Sort by Modification Date",
      callback: () => {
        this.toggleSortByModified();
      }
    });
    this.addCommand({
      id: "open-calendar-view",
      name: "Open Calendar View",
      callback: () => {
        this.activateCalendarView();
      }
    });
    this.registerView(CALENDAR_VIEW_TYPE, (leaf) => new CalendarView(leaf, this));
    this.addRibbonIcon("calendar", "Open Notes Calendar", () => {
      this.activateCalendarView();
    });
    this.updateAllFilesDisplay();
    this.setupFileClickListeners();
    this.addSettingTab(new NotesDatesSettingTab(this.app, this));
  }
  onunload() {
    this.cleanupFileDisplay();
  }
  cleanupFileDisplay() {
    const fileTitles = document.querySelectorAll(".nav-file-title");
    fileTitles.forEach((fileTitle) => {
      const fileTitleEl = fileTitle;
      const dateDisplays = fileTitleEl.querySelectorAll(".date-display");
      dateDisplays.forEach((el) => el.remove());
    });
    const folderTitles = document.querySelectorAll(".nav-folder-title");
    folderTitles.forEach((folderTitle) => {
      const folderTitleEl = folderTitle;
      const fileCounts = folderTitleEl.querySelectorAll(".file-count");
      fileCounts.forEach((el) => el.remove());
    });
    const fileTitlesWithListeners = document.querySelectorAll(".nav-file-title[data-calendar-listener]");
    fileTitlesWithListeners.forEach((fileTitle) => {
      var _a;
      const fileTitleEl = fileTitle;
      fileTitleEl.removeAttribute("data-calendar-listener");
      const clone = fileTitleEl.cloneNode(true);
      (_a = fileTitleEl.parentNode) == null ? void 0 : _a.replaceChild(clone, fileTitleEl);
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateAllFilesDisplay();
  }
  updateFileDisplay(_file) {
    this.updateAllFilesDisplay();
  }
  updateAllFilesDisplay() {
    this.updateFileExplorerDates();
  }
  updateFileExplorerDates() {
    setTimeout(() => {
      const fileTitles = document.querySelectorAll(".nav-file-title");
      const folderTitles = document.querySelectorAll(".nav-folder-title");
      fileTitles.forEach((fileTitleElement) => {
        const fileTitle = fileTitleElement;
        const filePath = fileTitle.getAttribute("data-path");
        if (filePath) {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file && file instanceof import_obsidian.TFile && file.extension === "md") {
            this.addDateDisplayToFileTitle(fileTitle, file);
          }
        }
      });
      if (this.settings.showFileCount) {
        folderTitles.forEach((folderTitleElement) => {
          const folderTitle = folderTitleElement;
          const folderPath = this.getFolderPathFromTitle(folderTitle);
          if (folderPath) {
            this.addFileCountToFolder(folderTitle, folderPath);
          }
        });
      }
    }, 100);
  }
  addDateDisplayToFileTitle(fileTitle, file) {
    const existingDate = fileTitle.querySelector(".date-display");
    if (existingDate) {
      existingDate.remove();
    }
    if (this.settings.showModificationDate || this.settings.showCreationDate) {
      const date = this.settings.showModificationDate ? file.stat.mtime : file.stat.ctime;
      const dateObj = new Date(date);
      const dateStr = this.formatCompactDate(dateObj);
      const dateDisplay = document.createElement("span");
      dateDisplay.className = "date-display";
      dateDisplay.textContent = dateStr;
      const fileTitleContent = fileTitle.querySelector(".nav-file-title-content");
      if (fileTitleContent) {
        fileTitleContent.appendChild(dateDisplay);
      } else {
        fileTitle.appendChild(dateDisplay);
      }
    }
  }
  formatCompactDate(date) {
    try {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const fileDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      if (fileDate.getTime() === today.getTime()) {
        return date.toLocaleTimeString("zh-CN", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false
        });
      }
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      if (fileDate.getTime() === yesterday.getTime()) {
        return "\u6628\u5929 " + date.toLocaleTimeString("zh-CN", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false
        });
      }
      return date.toLocaleDateString("zh-CN", {
        month: "short",
        day: "numeric"
      });
    } catch (error) {
      return "";
    }
  }
  getFolderPathFromTitle(folderTitle) {
    var _a, _b, _c, _d;
    let dataPath = folderTitle.getAttribute("data-path");
    if (dataPath) {
      return dataPath;
    }
    const folderText = (_a = folderTitle.querySelector(".nav-folder-title-content")) == null ? void 0 : _a.textContent;
    if (folderText) {
      const cleanFolderName = folderText.replace(/\s*\([^)]*\)\s*$/, "").trim();
      if (cleanFolderName) {
        return cleanFolderName;
      }
    }
    const folderContent = (_b = folderTitle.parentElement) == null ? void 0 : _b.querySelector(".nav-folder-children");
    if (folderContent) {
      const firstFile = folderContent.querySelector(".nav-file-title");
      if (firstFile) {
        const filePath = firstFile.getAttribute("data-path");
        if (filePath) {
          const parts = filePath.split("/");
          return parts.slice(0, -1).join("/");
        }
      }
    }
    const ariaLabel = folderTitle.getAttribute("aria-label");
    if (ariaLabel) {
      return ariaLabel.replace(/^Folder:\s*/, "");
    }
    const parentItem = folderTitle.closest("[data-list-item]");
    if (parentItem) {
      const listItemPath = parentItem.getAttribute("data-list-item");
      if (listItemPath) {
        return listItemPath;
      }
    }
    const pathParts = [];
    let currentElement = folderTitle;
    while (currentElement && !currentElement.classList.contains("nav-files-container")) {
      const folderTitleContent = currentElement.querySelector(".nav-folder-title-content");
      if (folderTitleContent) {
        const text = (_c = folderTitleContent.textContent) == null ? void 0 : _c.trim();
        if (text && !pathParts.includes(text)) {
          pathParts.unshift(text);
        }
      }
      currentElement = (_d = currentElement.parentElement) == null ? void 0 : _d.closest(".nav-folder");
    }
    if (pathParts.length > 0) {
      return pathParts.join("/");
    }
    return null;
  }
  addFileCountToFolder(folderTitle, folderPath) {
    const existingCount = folderTitle.querySelector(".file-count");
    if (existingCount) {
      existingCount.remove();
    }
    try {
      const stats = this.countFilesInFolder(folderPath);
      if (stats.totalFiles > 0) {
        const countDisplay = document.createElement("span");
        countDisplay.className = "file-count";
        countDisplay.textContent = formatFileCountText(stats.totalFiles, stats.totalNotes, this.settings.language);
        countDisplay.title = formatFileCountTooltip(stats.totalFiles, stats.totalNotes, this.settings.language);
        const folderTitleContent = folderTitle.querySelector(".nav-folder-title-content") || folderTitle;
        folderTitleContent.appendChild(countDisplay);
      }
    } catch (error) {
      console.debug("Error counting files in folder:", folderPath, error);
    }
  }
  countFilesInFolder(folderPath) {
    try {
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!folder || !("children" in folder)) {
        return { totalFiles: 0, totalNotes: 0, subfolderStats: [] };
      }
      const stats = { totalFiles: 0, totalNotes: 0, subfolderStats: [] };
      const children = folder.children;
      children.forEach((child) => {
        if (child instanceof import_obsidian.TFile) {
          stats.totalFiles++;
          if (child.extension === "md") {
            stats.totalNotes++;
          }
        } else if (child && "children" in child) {
          const subStats = this.countFilesInFolder(child.path);
          stats.totalFiles += subStats.totalFiles;
          stats.totalNotes += subStats.totalNotes;
          stats.subfolderStats.push({
            name: child.name,
            path: child.path,
            files: subStats.totalFiles,
            notes: subStats.totalNotes
          });
        }
      });
      return stats;
    } catch (error) {
      console.debug("Error counting files in folder:", folderPath, error);
      return { totalFiles: 0, totalNotes: 0, subfolderStats: [] };
    }
  }
  async toggleSortByModified() {
    const files = this.app.vault.getMarkdownFiles();
    const sortedFiles = files.sort((a, b) => {
      return b.stat.mtime - a.stat.mtime;
    });
    new import_obsidian.Notice(`Sorted ${sortedFiles.length} notes by modification date`);
  }
  async activateCalendarView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(CALENDAR_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: CALENDAR_VIEW_TYPE, active: true }));
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  setupFileClickListeners() {
    this.addFileClickListeners();
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          const addedNodes = Array.from(mutation.addedNodes);
          if (addedNodes.some((node) => node.nodeType === Node.ELEMENT_NODE && (node.querySelector(".nav-file-title") || node.querySelector(".nav-folder-title") || node.classList.contains("nav-file-title") || node.classList.contains("nav-folder-title")))) {
            setTimeout(() => {
              this.addFileClickListeners();
              this.updateFileExplorerDates();
            }, 100);
          }
        }
      });
    });
    const fileExplorer = document.querySelector(".nav-files-container");
    if (fileExplorer) {
      observer.observe(fileExplorer, {
        childList: true,
        subtree: true
      });
    }
    setInterval(() => this.addFileClickListeners(), 2e3);
  }
  addFileClickListeners() {
    const fileTitles = document.querySelectorAll(".nav-file-title");
    fileTitles.forEach((fileTitle) => {
      const fileTitleEl = fileTitle;
      const filePath = fileTitleEl.getAttribute("data-path");
      if (!filePath)
        return;
      if (fileTitleEl.hasAttribute("data-calendar-listener"))
        return;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian.TFile) || file.extension !== "md")
        return;
      fileTitleEl.setAttribute("data-calendar-listener", "true");
      const clickHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log("Calendar jump triggered for file:", file.path);
        this.jumpCalendarToFileDate(file);
      };
      fileTitleEl.addEventListener("click", clickHandler);
      fileTitleEl._calendarClickHandler = clickHandler;
    });
    if (this.settings.showFileCount) {
      const folderTitles = document.querySelectorAll(".nav-folder-title");
      folderTitles.forEach((folderTitle) => {
        const folderTitleEl = folderTitle;
        const existingCount = folderTitleEl.querySelector(".file-count");
        if (existingCount)
          return;
        const folderPath = this.getFolderPathFromTitle(folderTitleEl);
        if (folderPath) {
          this.addFileCountToFolder(folderTitleEl, folderPath);
        }
      });
    }
  }
  async jumpCalendarToFileDate(file) {
    try {
      console.log("Jumping to calendar for file:", file.path);
      await this.activateCalendarView();
      const calendarLeaves = this.app.workspace.getLeavesOfType(CALENDAR_VIEW_TYPE);
      if (calendarLeaves.length > 0) {
        const calendarView = calendarLeaves[0].view;
        const modDate = new Date(file.stat.mtime);
        console.log("Jumping to date:", modDate);
        const originalViewType = this.settings.calendarViewType;
        this.settings.calendarViewType = "month";
        await this.saveSettings();
        const controlsEl = calendarView.controlsEl;
        if (controlsEl) {
          const viewSwitcherBtn = controlsEl.querySelector(".view-switcher-btn");
          if (viewSwitcherBtn) {
            if (typeof calendarView.getViewSwitcherLabel === "function") {
              viewSwitcherBtn.textContent = calendarView.getViewSwitcherLabel();
              if (typeof calendarView.getViewSwitcherTooltip === "function") {
                viewSwitcherBtn.title = calendarView.getViewSwitcherTooltip();
              }
            }
          }
        }
        calendarView.currentDate = new Date(modDate);
        const monthYearEl = calendarView.monthYearEl;
        if (monthYearEl) {
          calendarView.renderCalendar(new Date(modDate), null, monthYearEl, modDate);
        }
        new import_obsidian.Notice(`\u5DF2\u8DF3\u8F6C\u5230 ${modDate.toLocaleDateString("zh-CN")} (\u6708\u89C6\u56FE)`, 2e3);
      } else {
        console.error("No calendar view found");
      }
    } catch (error) {
      console.error("Error jumping to file date:", error);
      new import_obsidian.Notice("\u8DF3\u8F6C\u5230\u65E5\u5386\u65F6\u51FA\u9519", 2e3);
    }
  }
};
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return CALENDAR_VIEW_TYPE;
  }
  getDisplayText() {
    return "Notes Calendar";
  }
  getIcon() {
    return "calendar";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h2", { text: getLocalizedText("notesCalendar", this.plugin.settings.language) });
    const controlsEl = container.createDiv("calendar-controls");
    const prevBtn = controlsEl.createEl("button", {
      text: "\u25C0",
      title: this.plugin.settings.language === "en" ? "Previous period" : "\u4E0A\u4E00\u4E2A\u65F6\u95F4\u6BB5"
    });
    const monthYearEl = controlsEl.createEl("span", { cls: "month-year-display" });
    const nextBtn = controlsEl.createEl("button", {
      text: "\u25B6",
      title: this.plugin.settings.language === "en" ? "Next period" : "\u4E0B\u4E00\u4E2A\u65F6\u95F4\u6BB5"
    });
    const newNoteBtn = controlsEl.createEl("button", {
      text: "+",
      title: "\u65B0\u5EFA\u7B14\u8BB0 - \u4F7F\u7528\u5F53\u524D\u65E5\u671F\u65F6\u95F4\u547D\u540D",
      cls: "new-note-button"
    });
    const viewSelectorEl = controlsEl.createDiv("view-selector-single");
    const viewSwitcherBtn = viewSelectorEl.createEl("button", {
      text: this.getViewSwitcherLabel(),
      title: this.getViewSwitcherTooltip(),
      cls: "view-switcher-btn"
    });
    viewSwitcherBtn.onclick = () => {
      const currentType = this.plugin.settings.calendarViewType;
      let nextType;
      switch (currentType) {
        case "year":
          nextType = "month";
          break;
        case "month":
          nextType = "year";
          break;
      }
      this.plugin.settings.calendarViewType = nextType;
      this.plugin.saveSettings();
      viewSwitcherBtn.textContent = this.getViewSwitcherLabel();
      viewSwitcherBtn.title = this.getViewSwitcherTooltip();
      const currentRef = this.currentDate || new Date();
      this.renderCalendar(currentRef, null, monthYearEl);
    };
    const sortSelectorEl = controlsEl.createDiv("sort-selector");
    const sortBtn = sortSelectorEl.createEl("button", {
      text: this.plugin.settings.sortOrder === "desc" ? "\u2193" : "\u2191",
      cls: "sort-button"
    });
    sortBtn.title = this.plugin.settings.sortOrder === "desc" ? "\u65F6\u95F4\u964D\u5E8F (\u6700\u65B0\u5728\u524D)" : "\u65F6\u95F4\u5347\u5E8F (\u6700\u65E7\u5728\u524D)";
    sortBtn.onclick = () => {
      const newSortOrder = this.plugin.settings.sortOrder === "desc" ? "asc" : "desc";
      this.plugin.settings.sortOrder = newSortOrder;
      this.plugin.saveSettings();
      sortBtn.textContent = newSortOrder === "desc" ? "\u2193" : "\u2191";
      sortBtn.title = newSortOrder === "desc" ? "\u65F6\u95F4\u964D\u5E8F (\u6700\u65B0\u5728\u524D)" : "\u65F6\u95F4\u5347\u5E8F (\u6700\u65E7\u5728\u524D)";
      const currentRef = this.currentDate || new Date();
      this.renderCalendar(currentRef, null, monthYearEl);
    };
    this.controlsEl = controlsEl;
    this.monthYearEl = monthYearEl;
    const calendarEl = container.createDiv("calendar-grid");
    this.calendarEl = calendarEl;
    const currentDate = new Date();
    this.currentDate = currentDate;
    this.renderCalendar(currentDate, null, monthYearEl);
    prevBtn.onclick = () => {
      this.navigateCalendar(-1, null, monthYearEl);
    };
    nextBtn.onclick = () => {
      this.navigateCalendar(1, null, monthYearEl);
    };
    newNoteBtn.onclick = () => {
      this.createNewNote();
    };
  }
  renderCalendar(date, _daysEl, monthYearEl, highlightDate) {
    const viewType = this.plugin.settings.calendarViewType;
    const calendarEl = this.calendarEl;
    calendarEl.empty();
    switch (viewType) {
      case "month":
        this.renderMonthView(date, calendarEl, monthYearEl, highlightDate);
        break;
      case "year":
        this.renderYearView(date, calendarEl, monthYearEl, highlightDate);
        break;
    }
  }
  renderMonthView(date, calendarEl, monthYearEl, highlightDate) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const monthNames = getMonthNames(this.plugin.settings.language);
    monthYearEl.textContent = `${monthNames[month]} ${year}`;
    const firstDayOfWeek = this.plugin.settings.calendarFirstDayOfWeek;
    const weekdayNames = getWeekdayNames(this.plugin.settings.language);
    let weekdays;
    if (firstDayOfWeek === 1) {
      weekdays = [weekdayNames[1], weekdayNames[2], weekdayNames[3], weekdayNames[4], weekdayNames[5], weekdayNames[6], weekdayNames[0]];
    } else {
      weekdays = [weekdayNames[0], weekdayNames[1], weekdayNames[2], weekdayNames[3], weekdayNames[4], weekdayNames[5], weekdayNames[6]];
    }
    const weekdayHeadersEl = calendarEl.createDiv("weekday-headers");
    weekdays.forEach((day) => {
      weekdayHeadersEl.createEl("div", { text: day, cls: "weekday-header" });
    });
    const daysEl = calendarEl.createDiv("calendar-days month-view");
    let firstDayOfMonth = new Date(year, month, 1).getDay();
    if (firstDayOfWeek === 1) {
      firstDayOfMonth = firstDayOfMonth === 0 ? 6 : firstDayOfMonth - 1;
    }
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const notes = this.plugin.app.vault.getMarkdownFiles();
    const notesByDate = {};
    notes.forEach((note) => {
      const noteDate = new Date(note.stat.mtime);
      if (noteDate.getFullYear() === year && noteDate.getMonth() === month) {
        const dateKey = noteDate.getDate().toString();
        if (!notesByDate[dateKey]) {
          notesByDate[dateKey] = [];
        }
        notesByDate[dateKey].push(note);
      }
    });
    for (let i = 0; i < firstDayOfMonth; i++) {
      daysEl.createEl("div", { cls: "calendar-day empty" });
    }
    for (let day = 1; day <= daysInMonth; day++) {
      const dayEl = daysEl.createEl("div", {
        text: day.toString(),
        cls: "calendar-day"
      });
      const currentDate = new Date(year, month, day);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      if (currentDate > today) {
        dayEl.addClass("future-date");
      }
      if (highlightDate && currentDate.getFullYear() === highlightDate.getFullYear() && currentDate.getMonth() === highlightDate.getMonth() && currentDate.getDate() === highlightDate.getDate()) {
        dayEl.addClass("highlighted-date");
      }
      const dayNotes = notesByDate[day.toString()];
      if (dayNotes && dayNotes.length > 0) {
        dayEl.addClass("has-notes");
        dayEl.createEl("span", {
          text: ` (${dayNotes.length})`,
          cls: "note-count"
        });
        dayEl.onclick = () => {
          this.showNotesForDate(dayNotes, day, month, year);
        };
        dayEl.title = `Click to see ${dayNotes.length} note(s)`;
      }
    }
  }
  renderWeekView(date, calendarEl, monthYearEl, highlightDate) {
    const year = date.getFullYear();
    const startOfWeek = new Date(date);
    let day = startOfWeek.getDay();
    const firstDayOfWeek = this.plugin.settings.calendarFirstDayOfWeek;
    if (firstDayOfWeek === 1) {
      day = day === 0 ? 6 : day - 1;
    }
    startOfWeek.setDate(date.getDate() - day);
    startOfWeek.setHours(0, 0, 0, 0);
    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 6);
    const monthNames = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    monthYearEl.textContent = `${monthNames[startOfWeek.getMonth()]} ${startOfWeek.getDate()} - ${monthNames[endOfWeek.getMonth()]} ${endOfWeek.getDate()}, ${year}`;
    const weekContainer = calendarEl.createDiv("week-view-timeline-container");
    const notes = this.plugin.app.vault.getMarkdownFiles();
    const weekNotes = [];
    console.log("Week range:", startOfWeek.toISOString(), "to", endOfWeek.toISOString());
    notes.forEach((note) => {
      const noteDate = new Date(note.stat.mtime);
      noteDate.setHours(0, 0, 0, 0);
      if (noteDate >= startOfWeek && noteDate <= endOfWeek) {
        weekNotes.push({ note, noteDate });
        console.log("Found note in week:", note.basename, noteDate.toISOString());
      }
    });
    if (this.plugin.settings.sortOrder === "desc") {
      weekNotes.sort((a, b) => b.note.stat.mtime - a.note.stat.mtime);
    } else {
      weekNotes.sort((a, b) => a.note.stat.mtime - b.note.stat.mtime);
    }
    const timeline = weekContainer.createDiv("timeline");
    console.log("Total notes found this week:", weekNotes.length);
    if (weekNotes.length === 0) {
      const noNotes = timeline.createDiv("no-notes-message");
      noNotes.textContent = "\u6CA1\u6709\u7B14\u8BB0\u5728\u672C\u5468\u4FEE\u6539";
      return;
    }
    weekNotes.forEach(({ note, noteDate }) => {
      const originalModTime = new Date(note.stat.mtime);
      const timelineItem = timeline.createDiv("timeline-item");
      const timelineDot = timelineItem.createDiv("timeline-dot week-timeline-dot");
      const dateTimeIndicator = timelineItem.createDiv("timeline-datetime");
      const weekdayNames = getWeekdayNames(this.plugin.settings.language);
      const localeString = this.plugin.settings.language === "en" ? "en-US" : "zh-CN";
      dateTimeIndicator.innerHTML = `
				<div class="timeline-date">${String(originalModTime.getDate()).padStart(2, "0")}</div>
				<div class="timeline-weekday">${weekdayNames[originalModTime.getDay()]}</div>
				<div class="timeline-time">${originalModTime.toLocaleTimeString(localeString, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      })}</div>
			`;
      const noteContent = timelineItem.createDiv("timeline-note-content");
      noteContent.style.cursor = "pointer";
      noteContent.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.plugin.app.workspace.getLeaf().openFile(note);
      };
      const noteTitle = noteContent.createEl("div", {
        text: note.basename,
        cls: "timeline-note-title"
      });
      const notePath = noteContent.createEl("div", {
        text: note.path,
        cls: "timeline-note-path"
      });
      this.addFirstLineToTimeline(noteContent, note);
      timelineItem.title = `${note.basename}
\u8DEF\u5F84: ${note.path}
\u4FEE\u6539\u65F6\u95F4: ${noteDate.toLocaleString("zh-CN")}`;
      if (highlightDate && noteDate.getFullYear() === highlightDate.getFullYear() && noteDate.getMonth() === highlightDate.getMonth() && noteDate.getDate() === highlightDate.getDate()) {
        timelineItem.addClass("highlighted-note");
      }
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const noteDay = new Date(noteDate);
      noteDay.setHours(0, 0, 0, 0);
      if (noteDay.getTime() === today.getTime()) {
        timelineItem.addClass("today-note");
      }
    });
  }
  renderYearView(date, calendarEl, monthYearEl, highlightDate) {
    const year = date.getFullYear();
    monthYearEl.textContent = `${year}`;
    const yearContainer = calendarEl.createDiv("year-view-timeline-container");
    const monthTimeline = yearContainer.createDiv("year-month-timeline");
    const monthTimelineContainer = monthTimeline.createDiv("year-month-timeline-container");
    const monthNames = getMonthNames(this.plugin.settings.language);
    const notes = this.plugin.app.vault.getMarkdownFiles();
    const notesByMonth = {};
    for (let i = 0; i < 12; i++) {
      notesByMonth[i] = [];
    }
    notes.forEach((note) => {
      const noteDate = new Date(note.stat.mtime);
      if (noteDate.getFullYear() === year) {
        notesByMonth[noteDate.getMonth()].push({ note, noteDate });
      }
    });
    Object.keys(notesByMonth).forEach((month) => {
      const monthNum = parseInt(month);
      if (this.plugin.settings.sortOrder === "desc") {
        notesByMonth[monthNum].sort((a, b) => b.note.stat.mtime - a.note.stat.mtime);
      } else {
        notesByMonth[monthNum].sort((a, b) => a.note.stat.mtime - b.note.stat.mtime);
      }
    });
    const currentMonth = new Date().getMonth();
    let selectedMonth = date.getMonth();
    monthNames.forEach((monthName, monthIndex) => {
      const monthNotes = notesByMonth[monthIndex];
      const monthItem = monthTimelineContainer.createEl("div", {
        cls: "year-month-timeline-item"
      });
      if (monthIndex === selectedMonth) {
        monthItem.addClass("active");
      }
      if (monthNotes.length > 0) {
        monthItem.addClass("has-notes");
      }
      const monthLabel = monthItem.createEl("div", {
        text: this.plugin.settings.language === "en" ? monthNames[monthIndex].substring(0, 3) : `${monthIndex + 1}\u6708`,
        cls: "year-month-timeline-month"
      });
      const noteCount = monthItem.createEl("div", {
        text: monthNotes.length.toString(),
        cls: "year-month-timeline-count"
      });
      monthItem.onclick = () => {
        monthTimelineContainer.querySelectorAll(".year-month-timeline-item").forEach((item) => {
          item.removeClass("active");
        });
        monthItem.addClass("active");
        selectedMonth = monthIndex;
        const monthSection = document.getElementById(`month-${monthIndex}`);
        if (monthSection) {
          monthSection.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      };
    });
    const timeline = yearContainer.createDiv("timeline");
    let totalNotes = 0;
    monthNames.forEach((monthName, monthIndex) => {
      const monthNotes = notesByMonth[monthIndex];
      totalNotes += monthNotes.length;
      const monthSection = timeline.createDiv("year-month-header");
      monthSection.id = `month-${monthIndex}`;
      let monthTitleText;
      if (this.plugin.settings.language === "en") {
        monthTitleText = monthNotes.length > 0 ? `${monthName} (${monthNotes.length} notes)` : `${monthName} (No notes)`;
      } else {
        monthTitleText = monthNotes.length > 0 ? `${monthName} (${monthNotes.length}\u4E2A\u7B14\u8BB0)` : `${monthName} (\u65E0\u7B14\u8BB0)`;
      }
      const monthTitle = monthSection.createEl("h3", {
        text: monthTitleText
      });
      monthNotes.forEach(({ note, noteDate }) => {
        const timelineItem = timeline.createDiv("timeline-item");
        const timelineDot = timelineItem.createDiv("timeline-dot");
        const dateTimeIndicator = timelineItem.createDiv("timeline-datetime");
        dateTimeIndicator.innerHTML = `
					<div class="timeline-date">${String(noteDate.getMonth() + 1).padStart(2, "0")}-${String(noteDate.getDate()).padStart(2, "0")}</div>
					<div class="timeline-time">${noteDate.toLocaleTimeString("zh-CN", {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false
        })}</div>
				`;
        const noteContent = timelineItem.createDiv("timeline-note-content");
        noteContent.style.cursor = "pointer";
        noteContent.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const noteMonth = noteDate.getMonth();
          const noteYear = noteDate.getFullYear();
          const monthNames2 = getMonthNames(this.plugin.settings.language);
          this.plugin.settings.calendarViewType = "month";
          this.plugin.saveSettings();
          const viewSwitcherBtn = document.querySelector(".view-switcher-btn");
          if (viewSwitcherBtn) {
            viewSwitcherBtn.textContent = this.getViewSwitcherLabel();
            viewSwitcherBtn.title = this.getViewSwitcherTooltip();
          }
          const targetDate = new Date(noteYear, noteMonth, 1);
          const monthYearEl2 = this.monthYearEl;
          if (monthYearEl2) {
            this.renderCalendar(targetDate, null, monthYearEl2, targetDate);
          }
          const jumpedToText = getLocalizedText("jumpedToMonthView", this.plugin.settings.language);
          const monthViewText = getLocalizedText("monthViewAbbr", this.plugin.settings.language);
          new import_obsidian.Notice(`${jumpedToText} ${monthNames2[noteMonth]} ${noteYear} ${monthViewText}`, 2e3);
        };
        const noteTitle = noteContent.createEl("div", {
          text: note.basename,
          cls: "timeline-note-title"
        });
        const notePath = noteContent.createEl("div", {
          text: note.path,
          cls: "timeline-note-path"
        });
        this.addFirstLineToTimeline(noteContent, note);
        timelineItem.title = `${note.basename}
\u8DEF\u5F84: ${note.path}
\u4FEE\u6539\u65F6\u95F4: ${noteDate.toLocaleString("zh-CN")}`;
        if (highlightDate && noteDate.getFullYear() === highlightDate.getFullYear() && noteDate.getMonth() === highlightDate.getMonth() && noteDate.getDate() === highlightDate.getDate()) {
          timelineItem.addClass("highlighted-note");
        }
      });
    });
    if (totalNotes === 0) {
      const noNotes = timeline.createDiv("no-notes-message");
      noNotes.textContent = `${year}\u5E74\u6CA1\u6709\u7B14\u8BB0`;
    }
    setTimeout(() => {
      const selectedMonthItem = monthTimelineContainer.querySelector(".year-month-timeline-item.active");
      if (selectedMonthItem) {
        selectedMonthItem.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "center" });
      }
    }, 100);
  }
  async addFirstLineToTimeline(noteContent, note) {
    try {
      const content = await this.plugin.app.vault.read(note);
      const lines = content.split("\n").filter((line) => line.trim().length > 0);
      if (lines.length > 0) {
        let firstLine = lines[0].trim();
        firstLine = firstLine.replace(/^#+\s*/, "").replace(/\*\*(.*?)\*\*/g, "$1").replace(/\*(.*?)\*/g, "$1").replace(/`(.*?)`/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").slice(0, 100);
        if (firstLine.length > 0) {
          const contentPreview = noteContent.createEl("div", {
            text: firstLine,
            cls: "timeline-note-preview"
          });
        }
      }
    } catch (error) {
      console.debug("Error reading file content for preview:", note.path, error);
    }
  }
  showNotesForDate(notes, day, month, year) {
    const modal = new DateNotesModal(this.plugin.app, notes, day, month, year, this.plugin);
    modal.open();
  }
  async createNewNote() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");
    const hour = String(now.getHours()).padStart(2, "0");
    const minute = String(now.getMinutes()).padStart(2, "0");
    const second = String(now.getSeconds()).padStart(2, "0");
    const fileName = `${year}-${month}-${day}-${hour}${minute}${second}.md`;
    try {
      const newFile = await this.plugin.app.vault.create(fileName, "");
      await this.plugin.app.workspace.getLeaf(true).openFile(newFile);
      new import_obsidian.Notice(`\u65B0\u5EFA\u7B14\u8BB0: ${fileName}`);
    } catch (error) {
      new import_obsidian.Notice(`\u521B\u5EFA\u7B14\u8BB0\u5931\u8D25: ${error.message}`);
    }
  }
  getViewSwitcherLabel() {
    const currentType = this.plugin.settings.calendarViewType;
    switch (currentType) {
      case "year":
        return getLocalizedText("yearToMonth", this.plugin.settings.language);
      case "month":
        return getLocalizedText("monthToYear", this.plugin.settings.language);
      default:
        return getLocalizedText("yearToMonth", this.plugin.settings.language);
    }
  }
  getViewTypeLabel() {
    const currentType = this.plugin.settings.calendarViewType;
    switch (currentType) {
      case "year":
        return getLocalizedText("yearView", this.plugin.settings.language);
      case "month":
        return getLocalizedText("monthView", this.plugin.settings.language);
      default:
        return getLocalizedText("yearView", this.plugin.settings.language);
    }
  }
  getViewSwitcherTooltip() {
    const currentType = this.getViewTypeLabel();
    const tooltipTemplate = getLocalizedText("switchViewTooltip", this.plugin.settings.language);
    return tooltipTemplate.replace("{current}", currentType);
  }
  async onClose() {
  }
  navigateCalendar(direction, _daysEl, monthYearEl) {
    const currentDate = this.currentDate || new Date();
    const viewType = this.plugin.settings.calendarViewType;
    switch (viewType) {
      case "month":
        currentDate.setMonth(currentDate.getMonth() + direction);
        break;
      case "year":
        currentDate.setFullYear(currentDate.getFullYear() + direction);
        break;
    }
    this.currentDate = new Date(currentDate);
    this.renderCalendar(this.currentDate, null, monthYearEl);
  }
  jumpToDate(date) {
    const monthYearEl = this.monthYearEl;
    if (monthYearEl) {
      this.renderCalendar(date, null, monthYearEl, date);
      setTimeout(() => {
        this.renderCalendar(date, null, monthYearEl);
      }, 3e3);
    }
  }
};
var DateNotesModal = class extends import_obsidian.Modal {
  constructor(app, notes, day, month, year, plugin) {
    super(app);
    this.notes = notes;
    this.day = day;
    this.month = month;
    this.year = year;
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    const headerContainer = contentEl.createDiv("modal-header-container");
    const monthNames = getMonthNames(this.plugin.settings.language);
    const titleSuffix = this.plugin.settings.language === "en" ? "notes" : "\u7684\u7B14\u8BB0";
    headerContainer.createEl("h2", {
      text: `${monthNames[this.month]} ${this.day}, ${this.year} ${titleSuffix}`
    });
    const sortControls = headerContainer.createDiv("modal-sort-controls");
    sortControls.style.marginTop = "1rem";
    const sortBtn = sortControls.createEl("button", {
      text: this.plugin.settings.sortOrder === "desc" ? this.plugin.settings.language === "en" ? "\u2193 Time Desc" : "\u2193 \u65F6\u95F4\u964D\u5E8F" : this.plugin.settings.language === "en" ? "\u2191 Time Asc" : "\u2191 \u65F6\u95F4\u5347\u5E8F",
      cls: "sort-button"
    });
    sortBtn.style.marginRight = "0.5rem";
    sortBtn.onclick = () => {
      const newSortOrder = this.plugin.settings.sortOrder === "desc" ? "asc" : "desc";
      this.plugin.settings.sortOrder = newSortOrder;
      this.plugin.saveSettings();
      sortBtn.textContent = newSortOrder === "desc" ? this.plugin.settings.language === "en" ? "\u2193 Time Desc" : "\u2193 \u65F6\u95F4\u964D\u5E8F" : this.plugin.settings.language === "en" ? "\u2191 Time Asc" : "\u2191 \u65F6\u95F4\u5347\u5E8F";
      sortBtn.title = newSortOrder === "desc" ? this.plugin.settings.language === "en" ? "Time Desc (Newest first)" : "\u65F6\u95F4\u964D\u5E8F (\u6700\u65B0\u5728\u524D)" : this.plugin.settings.language === "en" ? "Time Asc (Oldest first)" : "\u65F6\u95F4\u5347\u5E8F (\u6700\u65E7\u5728\u524D)";
      this.renderTimeline();
    };
    const timelineContainer = contentEl.createDiv("modal-timeline-container");
    this.timelineContainer = timelineContainer;
    this.renderTimeline();
  }
  async renderTimeline() {
    const timelineContainer = this.timelineContainer;
    timelineContainer.empty();
    if (this.plugin.settings.sortOrder === "desc") {
      this.notes.sort((a, b) => b.stat.mtime - a.stat.mtime);
    } else {
      this.notes.sort((a, b) => a.stat.mtime - b.stat.mtime);
    }
    const timeline = timelineContainer.createDiv("timeline");
    for (const note of this.notes) {
      const noteDate = new Date(note.stat.mtime);
      const timelineItem = timeline.createDiv("timeline-item");
      const timelineDot = timelineItem.createDiv("timeline-dot modal-timeline-dot");
      const dateTimeIndicator = timelineItem.createDiv("timeline-datetime");
      const weekdayNames = getWeekdayNames(this.plugin.settings.language);
      const localeString = this.plugin.settings.language === "en" ? "en-US" : "zh-CN";
      dateTimeIndicator.innerHTML = `
				<div class="timeline-date">${String(noteDate.getMonth() + 1).padStart(2, "0")}-${String(noteDate.getDate()).padStart(2, "0")}</div>
				<div class="timeline-weekday" style="font-size: 1.1em;">${weekdayNames[noteDate.getDay()]}</div>
				<div class="timeline-time">${noteDate.toLocaleTimeString(localeString, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      })}</div>
			`;
      const noteContent = timelineItem.createDiv("timeline-note-content");
      noteContent.style.cursor = "pointer";
      noteContent.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.app.workspace.getLeaf().openFile(note);
        this.close();
      };
      const noteTitle = noteContent.createEl("div", {
        text: note.basename,
        cls: "timeline-note-title"
      });
      const notePath = noteContent.createEl("div", {
        text: note.path,
        cls: "timeline-note-path"
      });
      await this.addFirstLineToModal(noteContent, note);
      timelineItem.title = `${note.basename}
\u8DEF\u5F84: ${note.path}
\u4FEE\u6539\u65F6\u95F4: ${noteDate.toLocaleString("zh-CN")}`;
    }
  }
  async addFirstLineToModal(noteContent, note) {
    try {
      const content = await this.app.vault.read(note);
      const lines = content.split("\n").filter((line) => line.trim().length > 0);
      if (lines.length > 0) {
        let firstLine = lines[0].trim();
        firstLine = firstLine.replace(/^#+\s*/, "").replace(/\*\*(.*?)\*\*/g, "$1").replace(/\*(.*?)\*/g, "$1").replace(/`(.*?)`/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").slice(0, 100);
        if (firstLine.length > 0) {
          const contentPreview = noteContent.createEl("div", {
            text: firstLine,
            cls: "timeline-note-preview"
          });
        }
      }
    } catch (error) {
      console.debug("Error reading file content for preview:", note.path, error);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NotesDatesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const descEl = containerEl.createEl("div", { cls: "setting-item-description" });
    descEl.innerHTML = `
			<h3>Notes Dates & Calendar Plugin</h3>
			<p><strong>Features:</strong></p>
			<ul>
				<li>Display creation and modification dates for notes in file explorer</li>
				<li>Show file and note counts in folders</li>
				<li>Interactive calendar view (Month, Week, Year) for browsing notes by date</li>
				<li>Jump to specific dates in calendar by clicking on files</li>
				<li>Sort notes by modification time (ascending/descending)</li>
				<li>Create new notes with current timestamp</li>
			</ul>
			<p>
				<strong>GitHub:</strong>
				<a href="https://github.com/your-username/notes-dates-calendar" target="_blank">Repository</a> |
				<a href="https://github.com/your-username/notes-dates-calendar/issues" target="_blank">Report a Bug</a>
			</p>
			<hr style="margin: 1rem 0; opacity: 0.2;">
		`;
    containerEl.createEl("h2", { text: "Settings" });
    new import_obsidian.Setting(containerEl).setName("Show Creation Date").setDesc("Display creation date in file explorer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCreationDate).onChange(async (value) => {
      this.plugin.settings.showCreationDate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Modification Date").setDesc("Display modification date in file explorer").addToggle((toggle) => toggle.setValue(this.plugin.settings.showModificationDate).onChange(async (value) => {
      this.plugin.settings.showModificationDate = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Format for displaying dates (using moment.js format)").addText((text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
      this.plugin.settings.dateFormat = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Calendar View").setDesc("Show calendar view for browsing notes by date").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCalendarView).onChange(async (value) => {
      this.plugin.settings.enableCalendarView = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show File Count in Folders").setDesc("Display the number of markdown files and notes in each folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFileCount).onChange(async (value) => {
      this.plugin.settings.showFileCount = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Subdirectory Statistics").setDesc("Display detailed file and note counts for subdirectories in folder titles").addToggle((toggle) => toggle.setValue(this.plugin.settings.showSubdirectoryStats).onChange(async (value) => {
      this.plugin.settings.showSubdirectoryStats = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Calendar First Day of Week").setDesc("Set the first day of the week in calendar (0 = Sunday, 1 = Monday)").addDropdown((dropdown) => dropdown.addOption("0", "Sunday").addOption("1", "Monday").setValue(this.plugin.settings.calendarFirstDayOfWeek.toString()).onChange(async (value) => {
      this.plugin.settings.calendarFirstDayOfWeek = parseInt(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Calendar View Type").setDesc("Choose the default calendar view type").addDropdown((dropdown) => dropdown.addOption("month", "Month View").addOption("year", "Year View").setValue(this.plugin.settings.calendarViewType).onChange(async (value) => {
      this.plugin.settings.calendarViewType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Calendar Sort Order").setDesc("Choose the default sort order for calendar notes").addDropdown((dropdown) => dropdown.addOption("desc", "Newest First (Time Descending)").addOption("asc", "Oldest First (Time Ascending)").setValue(this.plugin.settings.sortOrder).onChange(async (value) => {
      this.plugin.settings.sortOrder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Language").setDesc("Choose the interface language").addDropdown((dropdown) => dropdown.addOption("en", "English").addOption("zh", "\u4E2D\u6587").setValue(this.plugin.settings.language).onChange(async (value) => {
      var _a, _b;
      this.plugin.settings.language = value;
      await this.plugin.saveSettings();
      const calendarView = (_a = this.plugin.app.workspace.getLeavesOfType(CALENDAR_VIEW_TYPE)[0]) == null ? void 0 : _a.view;
      if (calendarView) {
        const monthYearEl = calendarView.monthYearEl;
        if (monthYearEl) {
          const currentDate = calendarView.currentDate || new Date();
          calendarView.renderCalendar(currentDate, null, monthYearEl);
        }
      }
      this.plugin.updateAllFilesDisplay();
      const existingCalendarView = (_b = this.plugin.app.workspace.getLeavesOfType(CALENDAR_VIEW_TYPE)[0]) == null ? void 0 : _b.view;
      if (existingCalendarView) {
        const controlsEl = existingCalendarView.controlsEl;
        if (controlsEl) {
          const prevBtn = controlsEl.querySelector("button");
          const nextBtn = controlsEl.querySelector("button:nth-of-type(2)");
          if (prevBtn) {
            prevBtn.title = this.plugin.settings.language === "en" ? "Previous period" : "\u4E0A\u4E00\u4E2A\u65F6\u95F4\u6BB5";
          }
          if (nextBtn) {
            nextBtn.title = this.plugin.settings.language === "en" ? "Next period" : "\u4E0B\u4E00\u4E2A\u65F6\u95F4\u6BB5";
          }
        }
      }
    }));
  }
};
module.exports = NotesDatesPlugin;
